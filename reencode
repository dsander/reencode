#!/usr/bin/env ruby

require 'pp'
require 'mediainfo'
require 'active_record'
require 'active_support'
require 'active_support/core_ext/numeric'
require 'shellwords'
require 'fileutils'
require 'thor'
require 'benchmark'

require_relative 'lib/qualities'
require_relative 'lib/medium'
require_relative 'lib/command'
require_relative 'lib/filecache'
require_relative 'lib/media_file'
require_relative 'lib/reencode'

$stopping = false

%w(INT TERM QUIT).each do |signal|
  Signal.trap(signal) { $stopping = true }
end

class Cli < Thor
  desc "perform PATH", "Scans the directory recursively and re-encodes all found videos"
  method_option :inplace, type: :boolean, default: false, desc: "Replaces the source file with the re-encoded"
  method_option :hardware_decode, type: :boolean, default: false, desc: "Use hardware accelerated decoding method"
  def perform(path)
    Reencode.work(options.merge(path: path)) do |file, c|
      next unless file.lock!

      (success, time) = c.execute
      if success
        Reencode.shell.say "  Measurements:", :yellow
        Reencode.shell.say "    Freed space  : #{Reencode.kb_to_human(file.size - c.destination_size)}"
        Reencode.shell.say "    Encoding time: #{time.to_i} seconds"
        FileUtils.mv(c.destination, file.path) if options['inplace']
      end
      file.unlock!
    end
  end

  desc "analyze PATH", "Scans the directory recursively and analyzes the potential saved space"
  def analyze(path)
    time = saved = 0
    Reencode.work(path: path) do |file, c|
      time += file.guessed_encoding_time
      saved += file.size - file.guessed_size
    end

    Reencode.shell.say "\n-------------------"
    Reencode.shell.say "Total estimations:", :green
    Reencode.shell.say "  Freed space  : #{Reencode.kb_to_human(saved)}"
    Reencode.shell.say "  Encoding time: #{(time / 3600.0 / 24.0).round(2)} days"
  end

  desc 'unlock', 'Unlocks all entries in the database (use to clean up after processing crashed)'
  def unlock
    Medium.where(locked: true).update_all(locked: false)
  end

  desc 'retry', 'Unmarks all previously failed encodings to allow them to be retried on the next run'
  def retry
    Medium.where(failed: true).update_all(failed: false)
  end
end

Cli.start
